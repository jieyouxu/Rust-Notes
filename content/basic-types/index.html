<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Basic Types - Rust Notes</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="../../prefix_content/introduction.html">Introduction</a></li><li class="expanded "><a href="../../content/preliminaries.html"><strong aria-hidden="true">1.</strong> Preliminaries</a></li><li class="expanded "><a href="../../content/basics/index.html"><strong aria-hidden="true">2.</strong> Basics</a></li><li><ol class="section"><li class="expanded "><a href="../../content/basics/example-cli.html"><strong aria-hidden="true">2.1.</strong> Example: Handling CLI Arguments</a></li><li class="expanded "><a href="../../content/basics/example-simple-web-server.html"><strong aria-hidden="true">2.2.</strong> Example: Simple Web Server</a></li><li class="expanded "><a href="../../content/basics/concurrency.html"><strong aria-hidden="true">2.3.</strong> Basic Concurrency</a></li><li class="expanded "><a href="../../content/basics/example-mandelbrot-set.html"><strong aria-hidden="true">2.4.</strong> Example: Mandelbrot Set</a></li></ol></li><li class="expanded "><a href="../../content/basic-types/index.html" class="active"><strong aria-hidden="true">3.</strong> Basic Types</a></li><li class="expanded "><a href="../../content/ownership/index.html"><strong aria-hidden="true">4.</strong> Ownership</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Rust Notes</h1>

                        <div class="right-buttons">
                            <a href="../../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#basic-types" id="basic-types">Basic Types</a></h1>
<blockquote>
<p>Reference: Programming Rust</p>
</blockquote>
<p>Rust has a few goals for the design of its type system, namely:</p>
<ol>
<li>
<p><strong>Safety</strong>:</p>
<p>Rust has a <em>strong</em>, <em>static</em> type system which helps to rule out some
classes of mistakes at compile-time (e.g. spelling mistakes!). For notorious
errros such as <code>null</code> references and pointers, Rust adopts type-level
guarantees such as the <code>Option</code> type and the <code>Result</code> type to force the user
to handle the different possibilities instead of delaying to exceptions in
run time.</p>
</li>
<li>
<p><strong>Efficiency</strong>:</p>
<p>Rust's type system is strong enough to allow fine-grained control over the
level of abstractions that is suitable to the programmer's problem domain.
When the programmer needs bare-metal / machine-level access, Rust has
support for such needs. Conversely, Rust's type system also supports
higher-level constructs such as <em>Algebraic Data Types</em> (via <code>enum</code>),
<code>struct</code>s, as well as <code>trait</code>s and generics. Currently, Rust also has
experimental support for associated types and constants, and is exploring
support towards <em>dependent types</em>, <em>refinement types</em>, <em>generic ADTs</em>,
<em>higher-kinded types</em> and more.</p>
</li>
<li>
<p><strong>Concision</strong>:</p>
<p>Rust has a good level of type inference built into the compiler. This means
that the Rust compiler is able to perform much of the type inference
requirement so users don't have to give explicit type signatures.</p>
</li>
</ol>
<p>As of right now, Rust is <em>compiled</em>.</p>
<h2><a class="header" href="#list-of-basic-types" id="list-of-basic-types">List of Basic Types</a></h2>
<table><thead><tr><th>Type</th><th>Description</th><th>Example Value(s)</th></tr></thead><tbody>
<tr><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code></td><td>Signed integers, fixed number of bits</td><td><code>-32</code></td></tr>
<tr><td><code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code></td><td>Unsigned integers, fixed number of bits</td><td><code>0</code></td></tr>
<tr><td><code>isize</code>, <code>usize</code></td><td>Machine-sized unsigned and signed integers</td><td><code>16</code></td></tr>
<tr><td><code>f32</code>, <code>f64</code></td><td>IEEE-754 compliant floating-point numbers</td><td><code>1.45</code>, <code>1.4f32</code></td></tr>
<tr><td><code>bool</code></td><td>Boolean</td><td><code>true</code>, <code>false</code></td></tr>
<tr><td><code>char</code></td><td>UTF-8 character, 32-bits</td><td><code>*</code></td></tr>
<tr><td><code>()</code></td><td>Unit type</td><td><code>()</code></td></tr>
<tr><td><code>(char, i32)</code></td><td>Tuple type (mixed product type)</td><td><code>('b', 0)</code></td></tr>
<tr><td><code>struct S { x: i32, y: f32 }</code></td><td>Struct with named fields</td><td><code>S { x: 0, y: 1.0 }</code></td></tr>
<tr><td><code>struct T(i32, char);</code></td><td>Tuple-like structure (gives name)</td><td><code>T(0, 'a')</code></td></tr>
<tr><td><code>struct E</code></td><td>Unit-like struct, no fields, zero-sized</td><td><code>E</code></td></tr>
<tr><td><code>enum Option&lt;T&gt; { Some(T), None }</code></td><td>Enum, algebraic data type (ADT)</td><td><code>Option::Some(2)</code>, <code>Option::None</code></td></tr>
<tr><td><code>Box&lt;Attend&gt;</code></td><td><code>Box</code> is an owning-pointer to some value allocated in heap</td><td><code>Box::new(3)</code></td></tr>
<tr><td><code>&amp;T</code></td><td>Immutable shared reference to some type <code>T</code>, non-owning</td><td><code>&amp;name</code></td></tr>
<tr><td><code>&amp;mut T</code></td><td>Mutable reference to some type <code>T</code>, non-owning</td><td><code>&amp;mut name</code></td></tr>
<tr><td><code>String</code></td><td>Dynamically-sized UTF-8 string, owned</td><td><code>&quot;Hello World&quot;</code></td></tr>
<tr><td><code>&amp;str</code></td><td>Non-owning reference to <code>str</code></td><td><code>&amp;s[0..12]</code></td></tr>
<tr><td><code>[T; N]</code></td><td>Fixed-length array of homogeneous type <code>T</code> of size <code>N</code></td><td><code>[0; 256]</code></td></tr>
<tr><td><code>Vec&lt;T&gt;</code></td><td>Dynamically-sized vector of homogeneous type <code>T</code></td><td><code>vec![0, 1, 2]</code></td></tr>
<tr><td><code>&amp;[T]</code></td><td>Immutable reference to a <em>slice</em>, a view into (a part of) an array</td><td><code>&amp;v[1..3]</code>, <code>&amp;x[..]</code></td></tr>
<tr><td><code>&amp;mut [T]</code></td><td>Mutable reference to a <em>slice</em></td><td><code>&amp;mut v[1..3]</code></td></tr>
<tr><td><code>&amp;Trait</code></td><td>Immutable reference to any value which implements the trait <code>Trait</code></td><td><code>value as &amp;Any</code></td></tr>
<tr><td><code>&amp;mut Trait</code></td><td>Mutable reference to any value which implements the trait <code>Trait</code></td><td><code>value as &amp;mut Any</code></td></tr>
<tr><td><code>fn(&lt;param&gt;, ...) -&gt; R</code></td><td>Pointer to function with parameters <code>&lt;param&gt;, ...</code> and return type <code>R</code></td><td><code>i32::saturating_add</code></td></tr>
<tr><td><code>&amp;#x7c; &lt;param&gt;, ... &amp;#x7c; &lt;expr&gt;</code></td><td>Closure capturing parameters <code>&lt;param, ...</code> with body <code>&lt;expr&gt;</code></td><td><code> &amp;#x7c; a, b &amp;#x7c; a + b</code></td></tr>
</tbody></table>
<h2><a class="header" href="#note-on-usize-and-isize" id="note-on-usize-and-isize">Note on <code>usize</code> and <code>isize</code></a></h2>
<p>These two types, <code>usize</code> and <code>isize</code>, correspond to the size of a pointer on the
target platform – meaning that different target platforms may produce different
sizes.</p>
<h2><a class="header" href="#arithmetic-overflow-checks" id="arithmetic-overflow-checks">Arithmetic Overflow Checks</a></h2>
<p>In <em>debug</em> builds, Rust checks for integer overflows and would produce a panic.</p>
<p>However, in <em>release</em> builds, overflows and underflows would cause <em>wrap</em>
behaviour. This should <em>not</em> be relied upon, and instead if the wrap behaviour
is intended, the <code>wrapping_add</code> method in <code>i*</code> and <code>u*</code> types should be used.</p>
<h2><a class="header" href="#integer-and-floating-point-number-literals" id="integer-and-floating-point-number-literals">Integer and Floating-Point Number Literals</a></h2>
<h3><a class="header" href="#suffixes" id="suffixes">Suffixes</a></h3>
<p>Integer literals may have their types appended, such as <code>32u8</code> to indicate the
size intended. The appended suffixes may also be omitted in which Rust will try
to infer the most suitable type, usually defaulting to the corresponding <code>isize</code>
which is usually the most efficient integer size on the target platform.</p>
<h3><a class="header" href="#prefixes" id="prefixes">Prefixes</a></h3>
<p>Rust allows binary, octet and hexadecimal literals as well, by prefixing <code>0b</code>,
<code>0o</code> and <code>0x</code> prefixes respectively.</p>
<h3><a class="header" href="#underscores" id="underscores">Underscores</a></h3>
<p>To separate the digits, Rust allows underscores <code>_</code> in between digits which are
discarded, e.g.<code>1_000_000</code>.</p>
<h3><a class="header" href="#byte-literals" id="byte-literals">Byte Literals</a></h3>
<p>Rust allows <em>byte literals</em> by prepending a <code>b</code> in front of single quote, e.g.
<code>b'\''</code> which is the numerical value of a single quote in ASCII.</p>
<h3><a class="header" href="#type-casting" id="type-casting">Type Casting</a></h3>
<p>Conversions between different numerical types are possible through type casts
via the <code>as</code> operator, e.g. <code>10u8 as u16</code>.</p>
<h2><a class="header" href="#boolean-type" id="boolean-type">Boolean Type</a></h2>
<p>The <code>bool</code> type in Rust is very strict – no implicit conversions from other
types to <code>bool</code> is predefined, so there are no notions of &quot;truthy&quot; or &quot;falsey&quot;
values.</p>
<h2><a class="header" href="#characters-and-strings" id="characters-and-strings">Characters and Strings</a></h2>
<p>Unlike in C, Rust's <code>char</code> type is a UTF-8 character, meaning that <code>char</code> is
32-bits or 4-bytes.</p>
<p>Rust <code>String</code> is <em>not</em> a vector of <code>char</code>s; instead, <code>String</code> is a vector of
UTF-8 bytes because some characters could be double-width.</p>
<p>Typical escape characters are supported in character and string literals.</p>
<h3><a class="header" href="#escape-sequences" id="escape-sequences">Escape Sequences</a></h3>
<table><thead><tr><th>Character</th><th>Literal</th></tr></thead><tbody>
<tr><td>Single Quote</td><td><code>'\''</code></td></tr>
<tr><td>Backslash</td><td><code>'\\'</code></td></tr>
<tr><td>Newline</td><td><code>'\n'</code></td></tr>
<tr><td>Carriage return</td><td><code>'\'r</code></td></tr>
<tr><td>Tab</td><td><code>'\t'</code></td></tr>
</tbody></table>
<p>Additionally, the code point could be written out:</p>
<ul>
<li>For Unicode point between <code>U+0000</code> and <code>U+007F</code>, characters may be written as
<code>\xHH</code> with <code>HH</code> being two hex digits.</li>
<li>For Unicode point beyond that range, characters may be written as <code>\u{HHHHHH}</code>
where <code>HHHHHH</code> are hex digits.</li>
</ul>
<p>A <code>char</code> may <em>not</em> be a surrogate pair half.</p>
<h2><a class="header" href="#pointer-types" id="pointer-types">Pointer Types</a></h2>
<p>Rust does <em>not</em> have garbage collection to minimize heap allocations and stack
allocations are preferred by default.</p>
<h3><a class="header" href="#references" id="references">References</a></h3>
<p>A <code>&amp;T</code> is a shared (immutable) reference to some type <code>T</code>. It can point to some
memory location either in the stack of the heap.</p>
<ul>
<li><code>&amp;x</code> <em>borrows</em> a reference to <code>x</code>.</li>
<li>Given some reference <code>r</code>, <code>*r</code> dereferences the reference to get its value.</li>
</ul>
<p>Rust references are <em>never</em> <code>null</code> and immutable by default.</p>
<p>A <code>&amp;mut T</code> is a mutable reference to some type <code>T</code>.</p>
<p>By tracking ownership + lifetimes of values, Rust can avoid mistakes such as:</p>
<ul>
<li>dangling pointers;</li>
<li>double frees; and</li>
<li>pointer invalidation.</li>
</ul>
<h3><a class="header" href="#boxes" id="boxes">Boxes</a></h3>
<p><code>Box</code>es are the simplest way to perform a heap allocation.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 12;
// b: Box&lt;i32&gt;
let b = Box::new(x);
<span class="boring">}
</span></code></pre></pre>
<p>When <code>b</code> goes out of scope, the memory is freed and reclaimed <em>unless</em> the value
<code>b</code> is <em>moved</em>, such as by returning it.</p>
<h3><a class="header" href="#raw-pointers" id="raw-pointers">Raw Pointers</a></h3>
<p>Rust also provides the raw pointer types:</p>
<ol>
<li>immutable raw pointer: <code>*const T</code>; and</li>
<li>mutable raw pointer: <code>*mut T</code>.</li>
</ol>
<p>Such usage of raw pointers are inherently unsafe and dereferences must be
performed within <code>unsafe {}</code> blocks, to opt-out of the borrow-checker. It is up
to the programmer, then, to ensure memory safety and coherence within <code>unsafe</code>
blocks.</p>
<h2><a class="header" href="#arrays-vectors-and-slices" id="arrays-vectors-and-slices">Arrays, Vectors and Slices</a></h2>
<p>Rust has three basic types for representing a contiguous sequence of values in
memory:</p>
<ol>
<li>
<p><strong>Fixed-size Array</strong>: <code>[T; N]</code></p>
<p>Represents an an array of <code>N</code> values of type <code>T</code>. The size of an array is
determined at compile-time and is enforced as part of the type; immutable.</p>
</li>
<li>
<p><strong>Vector</strong>: <code>Vec&lt;T&gt;</code></p>
<p>Represents a dynamically allocated sequence of values of type <code>T</code>. Elements
of a vector lives on the heap to allow resizing.</p>
</li>
<li>
<p><strong>Shared Slices</strong>: <code>&amp;[T]</code> and <code>&amp;mut [T]</code></p>
<ul>
<li>
<p><em>Shared slice</em>: <code>&amp;[T]</code>. A reference to a sequence of elements which is
part of some container such as an array or vector. Can be a sub-range of
the container. Immutable reference.</p>
</li>
<li>
<p><em>Mutable slice</em>: <code>&amp;mut [T]</code>. A reference to a sequence of element of some
container, can be used to modify arguments but cannot be shared.</p>
</li>
</ul>
</li>
</ol>
<p>The length can be obtained for each of these container types via the <code>len()</code>
function defined for these types. Accessing an element at index <code>i</code> can be done
via <code>v[i]</code> where <code>v</code> is the name of the container. Out-of-bounds will produce a
panic, and indicies into such container types is required to be of type <code>usize</code>.</p>
<h3><a class="header" href="#arrays" id="arrays">Arrays</a></h3>
<h4><a class="header" href="#array-literals" id="array-literals">Array Literals</a></h4>
<p>Array literals can be declared with the syntax</p>
<pre><code>name: [T; N] = [&lt;element&gt;, ...];
</code></pre>
<p>With <code>T</code> being the type and <code>N</code> the number of elements.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let elements: [u32; 6] = [1, 2, 3, 4, 5, 6];
let strings = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
<span class="boring">}
</span></code></pre></pre>
<p>Additionally, it is possible to initialize the entire array</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let elements = [true; 100];
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#vectors" id="vectors">Vectors</a></h3>
<p>Each vector <code>Vec&lt;T&gt;</code> is a resizable array allocated on the heap, containing
elements of type <code>T</code>.</p>
<p>The <code>vec!</code> macro may be used to create a vector, similar in syntax to arrays.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut v = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<p>Again, it is possible to repeat some value for a number of times</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut v = vec![true; 100];
<span class="boring">}
</span></code></pre></pre>
<p>The <code>vec!</code> macro is a syntax sugar for creating a new vector via <code>Vector::new</code>
and pushing the desired elements on to it via <code>v.push()</code>.</p>
<p>It is also possible to build a vector from an iterator, such as</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;i32&gt; = (0..5).collect();
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#initializing-with-capacity" id="initializing-with-capacity">Initializing with Capacity</a></h4>
<p>To resize the internal array representation within a <code>Vec&lt;T&gt;</code>, Rust will need to
create a larger new array and copy contents from the old array over. This is
both space and time costly, so the programmer should take care to specify a
suitable initial capacity whenever possible, by using the alternative
constructor <code>Vec::with_capacity</code>.</p>
<h3><a class="header" href="#slices" id="slices">Slices</a></h3>
<p>A <em>slice</em> <code>[T]</code> (with no length specified) represents a <em>region</em> of an array or
vector, and is always passed by reference since the length is arbitrary.</p>
<p>A reference to some slice is a <em>fat pointer</em>, containing:</p>
<table><thead><tr><th>Word</th><th>Value</th></tr></thead><tbody>
<tr><td><code>0</code></td><td>Pointer to element <code>i = 0</code> of the slice</td></tr>
<tr><td><code>1</code></td><td>Number of elements contained in the slice</td></tr>
</tbody></table>
<p>Rust is able to automatically convert between <code>&amp;Vec&lt;T&gt;</code> and <code>&amp;[T; N]</code> slice
references given the sizes are compatible.</p>
<p>Compared to normal references, a slice reference is a <em>non-owning</em> pointer to
multiple values (technically, to the first element of the part of the container
with multiple elements).</p>
<h4><a class="header" href="#sub-slicing" id="sub-slicing">Sub-slicing</a></h4>
<p>A reference to a slice of an array or vector, or a sub-slice of an existing
slice can be obtained via an integer range</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let v = [true; 10];
let w = &amp;v[5..9];
<span class="boring">}
</span></code></pre></pre>
<p>Given some source slice named <code>v</code>, then the following table lists the syntax for
getting sub-slices</p>
<table><thead><tr><th>Reference syntax</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>&amp;v[A..B]</code></td><td>A sub-slice starting from index <code>A</code> (inclusive) and ends at index <code>B</code> (exclusive).</td></tr>
<tr><td><code>&amp;v[A..]</code></td><td>A sub-slice starting at index <code>A</code>.</td></tr>
<tr><td><code>&amp;v[..B]</code></td><td>A sub-slice ending at index <code>B</code>.</td></tr>
</tbody></table>
<p>Note that indices are checked for out-of-bounds and a panic will be produced
upon illegal index access to prevent issues such as illegal memory access or
leaking possibly sensitive information in memory (e.g. heartbleed).</p>
<h2><a class="header" href="#strings" id="strings">Strings</a></h2>
<p>Rust, like C++, has two string types:</p>
<ol>
<li>Immutable string: <code>&amp;str</code>.</li>
<li>Mutable, growable string: <code>String</code>.</li>
</ol>
<h3><a class="header" href="#string-literals" id="string-literals">String Literals</a></h3>
<p>Strings are delimited with double quotes <code>&quot;</code>, and share backslash sequences with
<code>char</code> literals (with the difference that single quotes do not need backslashes
but double quotes do need escaping).</p>
<p>A string literal may span multiple lines. The newline character is included
provided that no backslash <code>\</code> ends the line.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let str_1 = &quot;hello
	world&quot;;
let str_2 = &quot;no \
	newline&quot;
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#raw-string-literals" id="raw-string-literals">Raw String Literals</a></h3>
<p>For convenience, Rust allows <em>raw string literals</em> by prepending the modifier
<code>r</code> before the string literal.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let raw_string = r&quot;C:\system32\folder&quot;;
let regex_pattern = Regex::new(r&quot;\d+&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>If double quotes need to be contained within, a longer version for raw string
literal is supported to remedy the problem of no escape characters being
recognized:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let raw_string_v2 = r###&quot;
	println!(&quot;hello world!&quot;);	
&quot;###;
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#byte-strings" id="byte-strings">Byte Strings</a></h3>
<p>For efficiency reasons, Rust also supports <em>byte string literals</em>. A <em>byte
string</em> is a slice of <code>u8</code> values instead of 4-byte <code>char</code> values.</p>
<p>A byte string literal is created by prepending <code>b</code> before the starting double
quote <code>&quot;</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let byte_str = b&quot;HELLO&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>Byte strings can only contain ASCII characters because of the size limit of 1
byte (escape sequences with <code>\xAA</code> is supported still).</p>
<h3><a class="header" href="#string-and-memory" id="string-and-memory">String and Memory</a></h3>
<p>Rust strings are stored as sequence of UTF-8 characters by default, but they are
<em>not</em> stored as array of <code>char</code>s because UTF-8 is a <em>variable-width</em> encoding.
Some characters may take up only 1 byte, while others can take up multiple
bytes.</p>
<ul>
<li>
<p>A <code>String</code> is an <em>owned</em> data type. It represents a resizable buffer holding
UTF-8 content, and is allocated on the heap. Under the hood, <code>String</code> is an
alias for <code>Vec&lt;u8&gt;</code> vector but implemented to check that its content is a
valid UTF-8 character sequence.</p>
</li>
<li>
<p>A <code>&amp;str</code> string slice is a reference to some part of a UTF-8. It is borrows
some string owned by someone else. Similar to vector or array slices, <code>&amp;str</code>
is a fat pointer with both the pointer to starting character as well as length
of string container. It is basically a <code>&amp;[u8]</code> slice that is promised to hold
well-formed UTF-8.</p>
</li>
<li>
<p>A <em>string literal</em> is preallocated and usually stored in read-only <code>.data</code>
segment within the compiled binary.</p>
<ul>
<li>
<p>Note that one may have to explicitly annotate the string literal with
<code>'static</code> lifetime:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let compile_time_constant_str: &amp;'static str = &quot;abc&quot;;
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#the-string-type" id="the-string-type">The <code>String</code> Type</a></h3>
<blockquote>
<p>Reference: <a href="https://doc.rust-lang.org/std/str/index.html">std::str</a>.</p>
</blockquote>
<ul>
<li><code>&amp;str</code> is similar to <code>&amp;[T]</code>;</li>
<li><code>String</code> is similar to <code>Vec&lt;T&gt;</code>.</li>
</ul>
<table><thead><tr><th>Behaviour</th><th><code>Vec&lt;T&gt;</code></th><th><code>String</code></th></tr></thead><tbody>
<tr><td>Auto buffer free</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Resizable</td><td>Yes</td><td>Yes</td></tr>
<tr><td><code>::new()</code> and <code>::with_capacity()</code></td><td>Yes</td><td>Yes</td></tr>
<tr><td><code>.reserve()</code> and <code>.capacity()</code></td><td>Yes</td><td>Yes</td></tr>
<tr><td><code>.push()</code> and <code>.pop()</code></td><td>Yes</td><td>Yes</td></tr>
<tr><td>Range syntax <code>v[start..end]</code></td><td>Yes (<code>-&gt; &amp;[T]</code>)</td><td>Yes (<code>-&gt; &amp;str</code>)</td></tr>
<tr><td>Auto conversion</td><td><code>&amp;Vec&lt;T&gt;</code> to <code>&amp;[T]</code></td><td><code>&amp;String</code> to <code>&amp;str</code></td></tr>
<tr><td>Inherites methods</td><td>From <code>&amp;[T]</code></td><td>From <code>&amp;str</code></td></tr>
</tbody></table>
<h4><a class="header" href="#creation-methods" id="creation-methods">Creation Methods</a></h4>
<ul>
<li>The <code>.to_string()</code> method converting from a string slice <code>&amp;str</code> to a <code>String</code>.</li>
<li>The <code>format!()</code> macro.</li>
<li>The <code>.concat()</code> and <code>.join(separator)</code> methods to build a new <code>String</code> from
existing strings or string slices.</li>
</ul>
<h4><a class="header" href="#usage" id="usage">Usage</a></h4>
<ul>
<li>Equality is supported by <code>==</code> and <code>!=</code> operators.</li>
<li>Case conversion:
<ul>
<li><code>.to_lowercase()</code></li>
<li><code>.to_uppercase()</code></li>
</ul>
</li>
<li>Substring contains check <code>.contains(substr)</code>.</li>
<li>Replacing: <code>.replace(regex, replacement)</code>.</li>
<li>Trimming whitespace: <code>.trim()</code>.</li>
<li>Splitting by separator: <code>.split(pattern)</code>.</li>
<li>Starts with: <code>.starts_with()</code>.</li>
<li>Ends with: <code>.ends_with()</code>.</li>
</ul>
<p>And more methods.</p>
<h3><a class="header" href="#alternative-string-types" id="alternative-string-types">Alternative String Types</a></h3>
<p>Sometimes <code>String</code>s are not necessarily valid Unicode, usually for interoperate
reasons.</p>
<table><thead><tr><th>Usage</th><th>Suitable Data Type</th><th>Documentation and Resources</th></tr></thead><tbody>
<tr><td>Unicode text</td><td><code>String</code>, <code>&amp;str</code></td><td><a href="https://doc.rust-lang.org/std/str/index.html">std::str</a></td></tr>
<tr><td>Filenames</td><td><code>std::path::PathBuf</code>, <code>&amp;Path</code></td><td><a href="https://doc.rust-lang.org/std/path/index.html">std::path</a></td></tr>
<tr><td>Binary data</td><td><code>Vec&lt;u8&gt;</code>, <code>&amp;[u8]</code></td><td><a href="https://doc.rust-lang.org/std/vec/index.html">std::vec</a>, <a href="https://doc.rust-lang.org/std/primitive.u8.html">u8</a></td></tr>
<tr><td>Environment variables, CLI arguments from the OS</td><td><code>OsString</code>, <code>&amp;OsStr</code></td><td><a href="https://doc.rust-lang.org/std/ffi/struct.OsString.html">std::ffi::OsString</a></td></tr>
<tr><td>C libraries, null-terminated strings</td><td><code>std::ffi::CString</code>, <code>&amp;CStr</code></td><td><a href="https://doc.rust-lang.org/std/ffi/struct.CString.html">std::ffi::CString</a></td></tr>
</tbody></table>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../content/basics/example-mandelbrot-set.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../content/ownership/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../../content/basics/example-mandelbrot-set.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../../content/ownership/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
